# Temporal Memory Graph (TMG) - 时序记忆图谱

> 以时间为核心轴的知识图谱系统，采用 Git-style 版本管理机制，支持概念边描述和双时间轴查询。

## 📌 核心设计理念

### 1. 设计哲学
- **时间即版本**：所有知识变更都有时间戳，可回溯任意时间点的知识状态
- **概念边取代标签边**：关系不再是简单的"位于"、"亲属"等标签，而是完整的自然语言描述
- **双时间轴**：物理时间（When it was recorded）+ 虚拟世界线时间（When it happened in context）
- **极简底层**：核心数据结构尽可能简单，复杂逻辑由大模型处理
- **记忆缓存驱动**：通过临时记忆缓存文档维护上下文，避免实体错配

### 2. 与传统知识图谱的区别

| 特性 | 传统知识图谱 | TMG |
|------|-------------|-----|
| 关系表示 | 固定标签 (is_a, located_in) | 概念边（自然语言描述） |
| 时间处理 | 静态或简单时间戳 | Git-style 版本控制 + 双时间轴 |
| 知识更新 | 覆盖式更新 | 追加式更新，保留历史 |
| 查询方式 | 结构化查询 | 支持时间点查询、范围查询、语义查询 |
| 实体对齐 | 基于规则 | 基于记忆缓存 + LLM 智能判断 |

---

## 🏗️ 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        Input Layer                               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │  小说    │  │  对话    │  │  网页    │  │  文档    │        │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘        │
└───────┼─────────────┼─────────────┼─────────────┼───────────────┘
        │             │             │             │
        └─────────────┴──────┬──────┴─────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Sliding Window Processor                       │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  [overlap]──[current window 1000]──[overlap]            │    │
│  └─────────────────────────────────────────────────────────┘    │
└────────────────────────────┬────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Memory Agent (LLM-based)                      │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  处理流程:                                                  │ │
│  │  1. 更新记忆缓存 ──► 2. 实体抽取+对齐 ──► 3. 关系抽取      │ │
│  │       │              │                    │                 │ │
│  │       ▼              ▼                    ▼                 │ │
│  │  4. 图谱搜索 ──► 5. 更新判断 ──► 6. 事件时间推断           │ │
│  │       │              │                    │                 │ │
│  │       └─────────────► 7. Commit ◄─────────┘                 │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              ▲                                   │
│                              │                                   │
│                     ┌────────┴────────┐                         │
│                     │  Memory Cache   │ (实时状态 + 版本保存)    │
│                     └─────────────────┘                         │
└────────────────────────────┬────────────────────────────────────┘
                             │
              ┌──────────────┼──────────────┐
              │ 查询已有知识 │              │ 提交变更
              ▼              │              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Git-Style Graph Manager                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Commit History:  c1 ──► c2 ──► c3 ──► c4 ──► HEAD      │    │
│  │                   │            │                        │    │
│  │                   └── 每个commit引用memory_cache_id ─────┘    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  Entity Versions        Relation Versions                  │ │
│  │  ┌─────┐               ┌─────┐                             │ │
│  │  │ v1  │──►│ v2 │      │ v1  │──►│ v2 │──►│ v3 │          │ │
│  │  └─────┘   └────┘      └─────┘   └────┘   └────┘          │ │
│  │  每个实体/关系都有独立的版本链（通过entity_id/relation_id）│ │
│  └────────────────────────────────────────────────────────────┘ │
└────────────────────────────┬────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Storage Layer                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐           │
│  │   SQLite     │  │    Markdown  │  │   向量DB     │           │
│  │  (结构数据)  │  │  (缓存文档)  │  │  (语义检索)  │           │
│  └──────────────┘  └──────────────┘  └──────────────┘           │
└─────────────────────────────────────────────────────────────────┘
```

---

## 📊 核心数据结构

### 1. MemoryCache（临时记忆缓存）- 文档化设计

**MemoryCache 字段：**

| 字段 | 类型 | 说明 |
|------|------|------|
| id | str | 缓存唯一ID（主键），每次处理新的text输入，都会创建一个全新的id |
| content | str | 简短的摘要总结缓存内容（文本形式，Markdown格式），记录当前的已有记忆、虚拟时间线、主要实体介绍、在阅读的文本文件名等一系列状态信息 |
| physical_time | datetime | 更新时间（物理时间） |

**content 示例格式：**
```markdown
当前摘要：主角林海正在探索神秘山洞，遇到了会说话的白狐。这是在林海根据古地图找到山洞后，进入山洞深处时发生的情况。重要细节包括：白狐的毛色是纯白色，眼睛闪烁着智慧的光芒；白狐主动开口说话，似乎对林海的到来并不意外；白狐提到了一些关于古地图和山洞的秘密，暗示这些都与某个古老的传说有关。

自我思考：
- 应该关注：白狐的身份和来历、它提到的古老传说、古地图与山洞的关系、这些秘密可能对后续情节的影响
- 预判重点：白狐可能是关键角色，它掌握的信息可能推动故事发展；古地图和山洞可能隐藏着重要的线索或宝藏；后续可能会揭示更多关于这个传说的内容
- 疑虑：白狐为什么会说话？它提到的秘密是什么？古地图的来源和真实性需要进一步验证

系统状态：
- 已处理文本范围：处理到"白狐似乎知道一些秘密"结束
- 当前文档名：三体.txt
```

**设计说明：**

1. **MemoryCache 本质是文档**：`content` 字段是完整的自然语言描述，保存为 Markdown 文件
2. **实时更新**：每个文本窗口处理时都会更新，保持当前上下文状态
3. **版本管理**：每次更新创建新的 id，旧的版本保留用于历史查询
4. **长度控制**：通过 LLM 自动维护，删除用不到的内容，加入新内容，保持合理长度

**MemoryCacheManager 方法：**

| 方法 | 输入 | 输出 | 说明 |
|------|------|------|------|
| `__init__` | storage_path: str | - | 初始化管理器，创建缓存目录 |
| `save_cache` | cache: MemoryCache | cache_id: str | 保存 cache，命名规则：cache_{timestamp}_{hash}.md |
| `load_cache` | cache_id: str | MemoryCache | 加载指定 ID 的 cache |
| `get_latest_cache` | activity_type: Optional[str] | Optional[MemoryCache] | 获取最新的 cache（可选按活动类型过滤） |

---

### 2. Entity（实体）- 带版本链的极简设计

**Entity 字段：**

| 字段 | 类型 | 说明 |
|------|------|------|
| id | str | 主键，唯一标识符 |
| entity_id | str | 实体的唯一ID，同一实体的不同版本具有相同的entity_id |
| name | str | 实体名称 |
| content | str | 实体的自然语言描述（包含所有信息） |
| physical_time | datetime | 物理时间，记录该版本创建的实际时间 |
| memory_cache_id | str | 记录当前更新是基于什么记忆环境下的判断 |

**设计说明：**

1. **版本管理**：
   - 同一实体的不同版本共享相同的 `entity_id`
   - 每次更新创建新的记录（新的 `id`），但 `entity_id` 保持不变
   - 查询历史时，按 `physical_time` 排序即可得到完整的版本链

2. **实体对齐**：
   - 同名但不同的实体有不同的 `entity_id` 和不同的 `content`
   - Memory Agent 通过 `name` + `content` 判断是否同一实体
   - 如果两个实体的 `name` 相同但 `content` 描述不同，则视为不同实体

3. **信息存储**：
   - 所有信息（类型、属性、上下文等）都写在 `content` 中
   - 格式自由，由 LLM 生成和理解

4. **别名处理**：
   - "林海" 和 "林博士" 是两个独立的实体（不同的 `entity_id`）
   - 它们之间通过概念边连接：`(林海) --["林海是一名考古学博士，他的同事都叫他林博士。"]--> (林博士)`

**示例：**
- 实体版本1: `{id: "id_001", entity_id: "ent_001", name: "主角A", content: "男性，30岁", physical_time: "2025-01-30 10:00:00", memory_cache_id: "cache_001"}`
- 实体版本2: `{id: "id_002", entity_id: "ent_001", name: "主角A", content: "女性，30岁，经历了变性手术", physical_time: "2025-01-30 10:30:00", memory_cache_id: "cache_015"}`

---

### 3. Relation（关系）- 带版本链的概念边（无向关系）

**Relation 字段：**

| 字段 | 类型 | 说明 |
|------|------|------|
| id | str | 主键 |
| relation_id | str | 关系的唯一ID，同一关系的不同版本具有相同的relation_id |
| entity1_absolute_id | str | 第一个实体的绝对ID（版本唯一ID，可以通过此ID找到entity_id） |
| entity2_absolute_id | str | 第二个实体的绝对ID（版本唯一ID，可以通过此ID找到entity_id） |
| content | str | 关系的自然语言描述 |
| physical_time | datetime | 物理时间 |
| memory_cache_id | str | 记录当前更新是基于什么记忆环境下的判断 |

**设计说明：**

1. **无向关系设计**：
   - 关系是无向的，不区分方向，只表示两个实体之间的关联
   - `entity1_absolute_id` 和 `entity2_absolute_id` 只是用来标识关系涉及的两个实体，没有方向性
   - 存储时，实体对按字母顺序排序（entity1 < entity2），确保 (A,B) 和 (B,A) 被视为同一个关系

2. **版本管理**：
   - 同一关系的不同版本共享相同的 `relation_id`
   - 每次更新创建新的记录（新的 `id`），但 `relation_id` 保持不变
   - 查询历史时，按 `physical_time` 排序即可得到完整的版本链

3. **概念边设计**：
   - 关系不再是简单的标签（如"位于"、"亲属"），而是完整的自然语言描述
   - 例如：`(林海) --["林海是一名考古学博士，他的同事都叫他林博士。"]-- (林博士)`
   - 保留完整语义信息，无需预定义关系类型

4. **关系更新判断**：
   - 通过比较 `content` 判断是否需要更新
   - 如果 `content` 完全相同或非常相似，可能不需要更新
   - 如果 `content` 有变化，创建新版本

**示例：**
- 关系版本1: `{id: "rel_001", relation_id: "rel_001", entity1_absolute_id: "entity_20250130_100000_abc12345", entity2_absolute_id: "entity_20250130_100000_def67890", content: "主角A是男性", physical_time: "2025-01-30 10:00:00", memory_cache_id: "cache_001"}`
- 关系版本2: `{id: "rel_002", relation_id: "rel_001", entity1_absolute_id: "entity_20250130_103000_abc12345", entity2_absolute_id: "entity_20250130_103000_def67890", content: "主角A是女性，经历了变性手术", physical_time: "2025-01-30 10:30:00", memory_cache_id: "cache_015"}`

**注意：** `entity1_absolute_id` 和 `entity2_absolute_id` 是实体的绝对ID（`entity.id`），而不是 `entity_id`。每个实体版本都有唯一的绝对ID，通过绝对ID可以找到对应的 `entity_id`。关系是无向的，`entity1` 和 `entity2` 只是标识符，不表示方向。

---
# Temporal_Memory_Graph
